%- Differential equation of the system -%
function dx = diffEqLink2_ms(t, x, z)
global bodyParam simParam ctrlParam simOutML last_mv
global onlineData
global currentTime

currentTime = t;

% Body parameters
m1  = bodyParam.m1;
J1  = bodyParam.J1;
L1  = bodyParam.L1;
h1  = bodyParam.h1;
m2  = bodyParam.m2;
J2  = bodyParam.J2;
h2  = bodyParam.h2;
g   = bodyParam.g;
%
dt = simParam.simSamp;

%-- Floor motion (Simulation duration: 20s, Floor tilts during 15-16s) --%
withFloorMotion = 1;
if(withFloorMotion)
    tiltStart = 15;   % (s)
    tiltEnd   = 16;   % (s)
    tiltAngle = bodyParam.tiltMax/180*pi; % Maximum tilt angle (default: 4 degree)
    if(t==tiltStart)
        phi      = 0;
        dPhi     = tiltAngle/(tiltEnd-tiltStart); % angular velocity
        lastDPhi = 0;
    elseif(t>tiltStart &&t<tiltEnd)
        phi  =tiltAngle/(tiltEnd-tiltStart)*(t-tiltStart); % Floor tilt angle
        dPhi =tiltAngle/(tiltEnd-tiltStart); % angular velocity
        lastDPhi = dPhi;
    elseif(t==tiltEnd)
        phi  = tiltAngle;
        dPhi = 0;
        lastDPhi = tiltAngle/(tiltEnd-tiltStart); % angular velocity
    elseif(t>tiltEnd)
        phi    = tiltAngle;
        dPhi   = 0;
        lastDPhi = dPhi;
    else
        phi  = 0;
        dPhi = 0;
        lastDPhi = 0;
    end
else
    phi = 0;
    dPhi= 0;
    lastDPhi = 0;
end
simOutML.phiList = [phi, dPhi]; % Save floor tilt angle and floor tilt angular velocity

% Variables without delay
dqList = [x(1);x(3)];
qList  = [x(2);x(4)];
q1  = qList(1);
q2  = qList(2);
dq1 = dqList(1);
dq2 = dqList(2);

%- Variables with delay
dqD1  = z(1);
qD1   = z(2);
dqD2  = z(3);
qD2   = z(4);

%========== Model Predictive Control =============%
[mv,onlineData] = mpcCtrlFunc([dqD1; qD1; dqD2; qD2; t; phi],last_mv, onlineData);
last_mv = mv;
%=================================================%

%- Noise -%
noiseNrm = randn; % Random number extracted from a normal distribution (for Ankle)
noiseA   = ctrlParam.sigma*noiseNrm/sqrt(dt); 
noiseNrm = randn; % Random number extracted from a normal distribution (for Hip)
noiseH   = ctrlParam.sigma*noiseNrm/sqrt(dt); 

%========== Setting muscles and torques ==========%
mv1 = mv(1);
mv2 = mv(2);
mv3 = mv(3);
% LLR
if(simParam.useReflection)
    if(t>tiltStart+0.100 && t<tiltStart+0.200) % 100ms time window starting 100ms after Floor Start
        mv2 = mv2+0.5; % 50% of activation added to GC
    end
end
%
simOutML.mv = [mv1,mv2,mv3]; % Save control inputs (determined by MPC)
%
% Active muscle forces generated by muscle contraction through motor commands (MPC)
[mTA_fm, mTA_lm, mTA_dLm]       = calcMuscleForce( mv1, 'TA',   q1, dq1, true); % TA
[mGC_fm, mGC_lm, mGC_dLm]       = calcMuscleForce( mv2, 'GC',   q1, dq1, false); % GC
[mIP_fm, mIP_lm, mIP_dLm]       = calcMuscleForce( mv3, 'IP',   q2, dq2, true);
[mGMax_fm, mGMax_lm, mGMax_dLm] = calcMuscleForce(-mv3, 'GMax', q2, dq2, false);
%
% Passive muscle forces due to muscle stiffness control
fmStiffTA   = calcFmStiff(mTA_lm,   mTA_dLm,   'TA', true);
fmStiffGC   = calcFmStiff(mGC_lm,   mGC_dLm,   'GC', true);
fmStiffIP   = calcFmStiff(mIP_lm,   mIP_dLm,   'IP', false);
fmStiffGMax = calcFmStiff(mGMax_lm, mGMax_dLm, 'GMax', false);
%
% Calculation of torque by muscles
%- Active torque -%
uA = -bodyParam.TA_ma*mTA_fm+bodyParam.GC_ma*mGC_fm;
uH = -bodyParam.IP_ma*mIP_fm+bodyParam.GMax_ma*mGMax_fm;
%- Passive torque -%
uAStiff = -bodyParam.TA_ma*fmStiffTA +bodyParam.GC_ma*fmStiffGC;
uHStiff = -bodyParam.IP_ma*fmStiffIP +bodyParam.GMax_ma*fmStiffGMax;
%
% Save 
simOutML.muscleU = [uA, uH];
simOutML.uStiff  = [uAStiff, uHStiff];
simOutML.U       = [uA + uAStiff, uH + uHStiff];
simOutML.noise   = [noiseA, noiseH]; % noise
%==================================================%

%==========     Equations of motion      ==========%
%- M term (Inertia)-%
M11 = J1 +J2 +m1*(h1^2) +m2*((L1^2)+(h2^2))+2*m2*L1*h2*cos(q2);
M12 = J2 +m2*h2^2+m2*L1*h2*cos(q2);
M21 = J2 +m2*h2^2+m2*L1*h2*cos(q2);
M22 = J2+m2*h2^2;
mMat = [M11 M12; M21 M22];
%
qf   = phi;   % Floor angle
dqf  = dPhi;  % Floor angular velocity
%
%- C term (Centrifugal force and Coriolis force) -%
C1_11 = m2*L1*h2*sin(q2)*(-2*dq1*dq2 -(dq2^2) -2*dq2*dqf);
C1_21 = m2*L1*h2*sin(q2)*(dq1^2 + 2*dq1*dqf +(dqf^2));
c1Mat = [C1_11; C1_21];
%
%- G term (Gravity) -%
G11 = -((m1*h1+m2*L1)*sin(q1+qf)+m2*h2*sin(q1+q2+qf));
G21 = -m2*h2*sin(q1+q2+qf);
gMat= [G11; G21];
%
% Active Torque term -%
ctrlTorque = [uA+noiseA-uH; uH+noiseH];
% Passive Torque term -%
tMat = [uAStiff-uHStiff; uHStiff];
%
%-- Equation of motion --%
mEqDDQ = pinv(mMat)*(-gMat*g -c1Mat +ctrlTorque +tMat -[1;0]*(dPhi-lastDPhi)/dt); %ddq1,ddq2
mEqDQ  = dqList; % dq1, dq2
simOutML.mEqDDQ   = [mEqDDQ(1), mEqDDQ(2)];
%
dx = [mEqDDQ(1); mEqDQ(1); mEqDDQ(2); mEqDQ(2)];
%==================================================%
end

%% Calculation of muscle force
function [fm, lm, dLm] = calcMuscleForce(act, muscleName, q, dq, isFront)
global bodyParam

fmBar = bodyParam.([muscleName '_fmBar']);
lmBar = bodyParam.([muscleName '_lmBar']);
dLmBar= bodyParam.([muscleName '_dLmBar']);
ma= bodyParam.([muscleName '_ma']);

if(isFront) % TA, IP
    lm  = lmBar+ma*q;
    dLm = ma*dq;
else
    lm  = lmBar-ma*q;
    dLm = -ma*dq;
end
if(act<0)
    act=0;
end

xi  = lm/lmBar;
fmPE=0.0159*fmBar*exp(5.9*lmBar*(xi-1)-1); % Parallel elastic elements
k = 0.32+0.71*exp(-1.112*(xi-1))*sin(3.722*(xi-0.656));
eta = dLm/dLmBar;
h = 1+tanh(3.0*eta);
fm= fmBar*k*h*act+fmPE;

if(fm<0)
    fm = 0;
elseif(fm>fmBar)
    fm = fmBar;
end
end

%% Muscle force by Stiffness Control
function fmStiff = calcFmStiff(lm, dLm, muscleName, isAnkle)
global bodyParam ctrlParam

lmBar  = bodyParam.([muscleName '_lmBar']);
ma     = bodyParam.([muscleName '_ma']);

if(isAnkle)
    kP = ((1/ma)^2)*ctrlParam.kPAStiff;
    kD = ((1/ma)^2)*ctrlParam.kDAStiff;
else
    kP = ((1/ma)^2)*ctrlParam.kPHStiff;
    kD = ((1/ma)^2)*ctrlParam.kDHStiff;
end

fm      = -kP*(lm-lmBar) -kD*dLm;
fmStiff = max([-fm,0]);
end
